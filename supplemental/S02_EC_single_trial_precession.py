# -*- coding: utf-8 -*-
"""
Created on Fri May 26 15:50:58 2023

@author: oliver
"""

import numpy as np
import os
import shelve
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import scipy.stats

#==============================================================================
# helper functions
#==============================================================================

def load_data(condition, gseed, n_poisson, cell_type):
    # cell_type should be 'grid' or 'granule'
    path = r"C:/Phase2RateData/tempotron/full/collective/"
    #path = r"C:/Phase2RateData/data.zip/data/main/full/collective/"
    path_adj = r"C:/Phase2RateData/tempotron/adjusted_weight/no-feedback/collective/"
    #path_adj = r"C:/Phase2RateData/data.zip/data/main/no-feedback/collective/tempotron_no-feedback/"
    # n_poisson = 4
    trajectory = [75]
    if condition == 'full':
        shuffling = "non-shuffled"
        fname = path + f'grid-seed_duration_shuffling_tuning_{gseed}_2000_{shuffling}_full'
        try:
            all_granule_spikes = load_spikes(fname, cell_type, trajectory, n_poisson)[75]
        except:
            fname = path + f'grid-seed_duration_shuffling_tuning_trajs_{gseed}_2000_{shuffling}_full_75-60'
            all_granule_spikes = load_spikes(fname, cell_type, trajectory, n_poisson)[75]
    elif condition == 'shuffled':
        shuffling = "shuffled"
        fname = path + f'grid-seed_duration_shuffling_tuning_{gseed}_2000_{shuffling}_full'
        try:
            all_granule_spikes = load_spikes(fname, cell_type, trajectory, n_poisson)[75]
        except:
            fname = path + f'grid-seed_duration_shuffling_tuning_trajs_{gseed}_2000_{shuffling}_full_75-60'
            all_granule_spikes = load_spikes(fname, cell_type, trajectory, n_poisson)[75]
    elif condition == "noFB":
        shuffling = "non-shuffled"
        fname_adj = path_adj + f'grid-seed_duration_shuffling_tuning_trajs_{gseed}_2000_{shuffling}_no-feedback-adjusted_75-60'
        all_granule_spikes = load_spikes(fname_adj, cell_type, trajectory, n_poisson)[75]
    elif condition == "noFBshuffled":
        shuffling = "shuffled"
        fname_adj = path_adj + f'grid-seed_duration_shuffling_tuning_trajs_{gseed}_2000_{shuffling}_no-feedback-adjusted_75-60'
        all_granule_spikes = load_spikes(fname_adj, cell_type, trajectory, n_poisson)[75]

    index_dict = {}
    spike_time_dict = {}
    for pseed in range(n_poisson):
        # print(pseed)
        try:
            granule_spikes = all_granule_spikes[pseed]
        except:
            print('error loading data')
            print('condition', condition)
            print('gseed', gseed)
            print('pseed', pseed)
        index_list = []
        spike_time_list = []
        for index, spike_times in enumerate(granule_spikes):
            for time in spike_times:
                index_list.append(index)
                spike_time_list.append(time)
        index_dict[pseed] = np.array(index_list)
        spike_time_dict[pseed] = np.array(spike_time_list)
    return (index_dict, spike_time_dict)

def load_spikes(path, cell_type, trajectories, n_samples):
    """

    Load the spike times from the data generated by simulations.

    Parameters
    ----------
    path : str
        Data loading path.
    cell_type : str
        "grid" or "granule".
    trajectories : list
        List of trajectories.
    n_samples : int
        Number of samples.

    Raises
    ------
    Exception
        If cell type or n_samples is not valid.

    Returns
    -------
    spikes : dict
        returns loaded spikes from different trajectories.

    """
    if not os.path.exists(path+'.dir'):
        print(path)
        raise Exception('Path does not exist!')

    storage = shelve.open(path)
    spikes = {}
    for traj in trajectories:
        requested_spikes = []
        traj_key = str(traj)
        poisson_seeds = storage[traj_key]["parameters"]["poisson_seeds"]
        if n_samples > len(poisson_seeds):
            raise Exception("Too much samples requested!")
        elif n_samples < 1:
            raise Exception("n_samples should be larger than 0!")
        else:
            poisson_seeds = poisson_seeds[0:n_samples]

        if cell_type == "grid":
            all_spikes = storage[traj_key]["grid_spikes"]
        elif cell_type == "granule":
            all_spikes = storage[traj_key]["granule_spikes"]
        else:
            raise Exception("Cell type does not exist!")
        for poisson in poisson_seeds:
            requested_spikes.append(all_spikes[poisson])
        spikes[traj] = requested_spikes
    storage.close()
    return spikes


#==============================================================================
# compute phase variance per bin & show phase-precession for random grid cells
#==============================================================================

P_seeds = 20
index_dict,spike_time_dict = load_data('full',11,P_seeds,'grid')
#index_dict,spike_time_dict = load_data('full',11,P_seeds,'granule')
indi = []
spike_times = []
spike_phases = []
for P_seed in range(P_seeds):
    indi = np.concatenate((indi,index_dict[P_seed].flatten()))
    spike_times = np.concatenate((spike_times, spike_time_dict[P_seed].flatten()))
spike_phases = (spike_times%100)/100*360
EC_array = np.array([indi,spike_times,spike_phases])   
df_EC = pd.DataFrame(EC_array.T, columns=['cell','time','phase'])

index_dict,spike_time_dict = load_data('full',11,P_seeds,'granule')
indi = []
spike_times = []
spike_phases = []
for P_seed in range(P_seeds):
    indi = np.concatenate((indi,index_dict[P_seed].flatten()))
    spike_times = np.concatenate((spike_times, spike_time_dict[P_seed].flatten()))
spike_phases = (spike_times%100)/100*360
GC_array = np.array([indi,spike_times,spike_phases])   
df_GC = pd.DataFrame(GC_array.T, columns=['cell','time','phase'])

f1, ax_array = plt.subplots(5, 8, figsize=(15, 10))
#f1.subplots_adjust(hspace=.6, wspace=.6, left=0.1, right=0.9)

for cell,ax in enumerate(f1.axes):
    cell_df=df_EC[df_EC['cell']==cell]
    cell_array = np.zeros(2000)
    for i in range(2000):
        rounded_spike_times = round(cell_df["time"])
        for t in rounded_spike_times: 
            if i == t:
                cell_array[i]=1

    sns.kdeplot(data=cell_df,x="time",y="phase", fill="true", cmap='RdYlBu_r',
                levels=30, ax=ax)
    ax.set_xlim([0,2000])
    ax.set_ylim([0,360])
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_ylabel('')
    ax.set_xlabel('')

#f1.savefig('S2_Grid_cells.pdf')

df_EC = pd.DataFrame(EC_array.T, columns=['cell','time','phase'])
#f2, ax_array = plt.subplots(5, 8, figsize=(15, 10))
#f2.subplots_adjust(hspace=.6, wspace=.6, left=0.1, right=0.9)

EC_bin_list_vars = []
EC_cell_list_mods =[]
EC_cell_list_phases =[]
for cell,ax in enumerate(f1.axes):
    cell_df = df_EC[df_EC['cell']==cell]
    if len(cell_df)>8:
        cell_df = cell_df.round()
        cycle = np.arange(20)
        phase_means = np.zeros(20)
        phase_vars = np.zeros(20)
        for tbin in cycle:
            tbin_df = cell_df[cell_df['time'].isin(range(tbin*100,tbin*100+100))]
            tbin_df['phase'] = tbin_df['phase']/360*2*np.pi
            phase_means[tbin] = scipy.stats.circmean(tbin_df["phase"])
            phase_vars[tbin] = scipy.stats.circvar(tbin_df["phase"])
            EC_bin_list_vars.append(scipy.stats.circvar(tbin_df["phase"])/2/np.pi*360)
        
        #compute modulation (in radians)
        cell_df['phase'] = cell_df['phase']/360*2*np.pi
        x = 0
        y = 0
        for AP in cell_df['phase']:
            x += np.cos(AP)
            y += np.sin(AP)
        EC_cell_list_mods.append(np.sqrt(x**2 + y**2)/len(cell_df))
        EC_cell_list_phases.append(scipy.stats.circmean(cell_df["phase"])/2/np.pi*360)
        #ax.step(cycle,phase_vars/2/np.pi*360)
        #ax.set_ylim([0,360])

df_GC = pd.DataFrame(GC_array.T, columns=['cell','time','phase'])
#f2, ax_array = plt.subplots(5, 8, figsize=(15, 10))
#f2.subplots_adjust(hspace=.6, wspace=.6, left=0.1, right=0.9)

GC_bin_list_vars = []
GC_cell_list_mods =[]
GC_cell_list_phases =[]
for cell,ax in enumerate(f1.axes):
    cell_df = df_GC[df_GC['cell']==cell]
    if len(cell_df)>8:
        cell_df = cell_df.round()
        cycle = np.arange(20)
        phase_means = np.zeros(20)
        phase_vars = np.zeros(20)
        for tbin in cycle:
            tbin_df = cell_df[cell_df['time'].isin(range(tbin*100,tbin*100+100))]
            tbin_df['phase'] = tbin_df['phase']/360*2*np.pi
            phase_means[tbin] = scipy.stats.circmean(tbin_df["phase"])
            phase_vars[tbin] = scipy.stats.circvar(tbin_df["phase"])
            GC_bin_list_vars.append(scipy.stats.circvar(tbin_df["phase"])/2/np.pi*360)
            
        #compute modulation (in radians)
        cell_df['phase'] = cell_df['phase']/360*2*np.pi
        x = 0
        y = 0
        for AP in cell_df['phase']:
            x += np.cos(AP)
            y += np.sin(AP)
        GC_cell_list_mods.append(np.sqrt(x**2 + y**2)/len(cell_df))
        GC_cell_list_phases.append(scipy.stats.circmean(cell_df["phase"])/2/np.pi*360)
        #ax.step(cycle,phase_vars/2/np.pi*360)
        #ax.set_ylim([0,360])

#==============================================================================
# compute single trial phase ranges analogous to Ebbesen et al., 2016.
#==============================================================================

path = 'C:/phase-to-rate/figure01_D_spike_trains.pkl'
df = pd.read_pickle(path)

ranges = []
slopes = []
f2, ax_array = plt.subplots(5,1, figsize=(8, 5))
for i,cell in enumerate(df):
    cell = cell*1000 #convert to ms
    x= cell
    y= cell % 100/ 100 * 360
    ax = ax_array[i]
    ax.scatter(x,y,marker='|', c='k')
    ax.set_ylim([0,360])
    ax.set_xlim([0,2000])
    
    for field_traversal in [1,2]:
        if field_traversal == 1:
            mask = np.where(x<1000)
        else:
            mask = np.where(x>1000)
        x1= x[mask]
        y1= y[mask]
        coeffs = np.polyfit(x1, y1, 1)
        fit_x = np.arange(min(x1),max(x1),2)
        fit_y = fit_x * coeffs[0] + coeffs[1]
        ax.plot(fit_x,fit_y)  
        slopes.append(coeffs[0]*1000)
        ranges.append(max(fit_y)-min(fit_y))

#f2.savefig('S2_ranges_in_degree.svg', dpi=200)

#==============================================================================
# summary statistics
#==============================================================================

f3, ([ax1,ax2,ax3,ax4,ax5,ax6]) = plt.subplots(1, 6, figsize=(10, 2))
f3.subplots_adjust(hspace=.6, wspace=.6, left=0.1, right=0.9)
ax1.set_title('phase variance within theta bins')
ax1.hist(EC_bin_list_vars,color='grey')
ax2.hist(GC_bin_list_vars,color='blue')


print('mean variance EC: {}'.format(np.nanmean(EC_bin_list_vars)))
print('mean variance GC: {}'.format(np.nanmean(GC_bin_list_vars)))

#phase ranges
lit_ranges = ranges.copy()
lit_ranges.append(127.5)
lit_ranges.append(169)
labels = len(ranges)*['model'] + ['Ebbesen'] + ['Reifenstein']
df = pd.DataFrame(list(zip(lit_ranges, labels)), columns=['value','label'])

sns.boxplot(EC_bin_list_vars, color='grey', ax=ax3)
ax3.set_ylabel('within bin phase variance (°)')
sns.boxplot(GC_bin_list_vars, color='blue', ax=ax4)
ax5.set_ylabel('single trial phase ranges (°)')
sns.boxplot(data=df, x='label', y='value',color='grey', ax=ax5)
ax5.set_xticklabels(['model','Ebbesen et al. 2016', 'Reifenstein et al. 2016']
                    , rotation=60)


#f3.savefig('S2_phase_stats.pdf')


